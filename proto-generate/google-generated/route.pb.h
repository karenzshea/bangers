// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#ifndef PROTOBUF_route_2eproto__INCLUDED
#define PROTOBUF_route_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_route_2eproto();
void protobuf_AssignDesc_route_2eproto();
void protobuf_ShutdownFile_route_2eproto();

class Waypoint;
class BoundingBox;
class StreetName;
class Step;
class SignElement;
class Sign;
class Lane;
class Maneuver;
class Leg;
class Route;
class Directions;

// ===================================================================

class Waypoint : public ::google::protobuf::Message {
 public:
  Waypoint();
  virtual ~Waypoint();

  Waypoint(const Waypoint& from);

  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Waypoint& default_instance();

  void Swap(Waypoint* other);

  // implements Message ----------------------------------------------

  Waypoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Waypoint& from);
  void MergeFrom(const Waypoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline float lon() const;
  inline void set_lon(float value);

  // optional string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional uint32 bearing = 4;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 4;
  inline ::google::protobuf::uint32 bearing() const;
  inline void set_bearing(::google::protobuf::uint32 value);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string street = 6;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 6;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string side_of_street = 7;
  inline bool has_side_of_street() const;
  inline void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 7;
  inline const ::std::string& side_of_street() const;
  inline void set_side_of_street(const ::std::string& value);
  inline void set_side_of_street(const char* value);
  inline void set_side_of_street(const char* value, size_t size);
  inline ::std::string* mutable_side_of_street();
  inline ::std::string* release_side_of_street();
  inline void set_allocated_side_of_street(::std::string* side_of_street);

  // @@protoc_insertion_point(class_scope:valhalla.Waypoint)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_side_of_street();
  inline void clear_has_side_of_street();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float lat_;
  float lon_;
  ::std::string* type_;
  ::std::string* name_;
  ::std::string* street_;
  ::std::string* side_of_street_;
  ::google::protobuf::uint32 bearing_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Waypoint* default_instance_;
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::Message {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox& default_instance();

  void Swap(BoundingBox* other);

  // implements Message ----------------------------------------------

  BoundingBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_lat = 1;
  inline bool has_min_lat() const;
  inline void clear_min_lat();
  static const int kMinLatFieldNumber = 1;
  inline float min_lat() const;
  inline void set_min_lat(float value);

  // optional float min_lon = 2;
  inline bool has_min_lon() const;
  inline void clear_min_lon();
  static const int kMinLonFieldNumber = 2;
  inline float min_lon() const;
  inline void set_min_lon(float value);

  // optional float max_lat = 3;
  inline bool has_max_lat() const;
  inline void clear_max_lat();
  static const int kMaxLatFieldNumber = 3;
  inline float max_lat() const;
  inline void set_max_lat(float value);

  // optional float max_lon = 4;
  inline bool has_max_lon() const;
  inline void clear_max_lon();
  static const int kMaxLonFieldNumber = 4;
  inline float max_lon() const;
  inline void set_max_lon(float value);

  // @@protoc_insertion_point(class_scope:valhalla.BoundingBox)
 private:
  inline void set_has_min_lat();
  inline void clear_has_min_lat();
  inline void set_has_min_lon();
  inline void clear_has_min_lon();
  inline void set_has_max_lat();
  inline void clear_has_max_lat();
  inline void set_has_max_lon();
  inline void clear_has_max_lon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float min_lat_;
  float min_lon_;
  float max_lat_;
  float max_lon_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class StreetName : public ::google::protobuf::Message {
 public:
  StreetName();
  virtual ~StreetName();

  StreetName(const StreetName& from);

  inline StreetName& operator=(const StreetName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetName& default_instance();

  void Swap(StreetName* other);

  // implements Message ----------------------------------------------

  StreetName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetName& from);
  void MergeFrom(const StreetName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool is_route_number = 2;
  inline bool has_is_route_number() const;
  inline void clear_is_route_number();
  static const int kIsRouteNumberFieldNumber = 2;
  inline bool is_route_number() const;
  inline void set_is_route_number(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.StreetName)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_is_route_number();
  inline void clear_has_is_route_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  bool is_route_number_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static StreetName* default_instance_;
};
// -------------------------------------------------------------------

class Step : public ::google::protobuf::Message {
 public:
  Step();
  virtual ~Step();

  Step(const Step& from);

  inline Step& operator=(const Step& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Step& default_instance();

  void Swap(Step* other);

  // implements Message ----------------------------------------------

  Step* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Step& from);
  void MergeFrom(const Step& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float distance = 1;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 1;
  inline float distance() const;
  inline void set_distance(float value);

  // optional uint32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional uint32 geometry_index_begin = 3;
  inline bool has_geometry_index_begin() const;
  inline void clear_geometry_index_begin();
  static const int kGeometryIndexBeginFieldNumber = 3;
  inline ::google::protobuf::uint32 geometry_index_begin() const;
  inline void set_geometry_index_begin(::google::protobuf::uint32 value);

  // optional uint32 geometry_index_end = 4;
  inline bool has_geometry_index_end() const;
  inline void clear_geometry_index_end();
  static const int kGeometryIndexEndFieldNumber = 4;
  inline ::google::protobuf::uint32 geometry_index_end() const;
  inline void set_geometry_index_end(::google::protobuf::uint32 value);

  // optional uint32 incoming_maneuver_index = 5;
  inline bool has_incoming_maneuver_index() const;
  inline void clear_incoming_maneuver_index();
  static const int kIncomingManeuverIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 incoming_maneuver_index() const;
  inline void set_incoming_maneuver_index(::google::protobuf::uint32 value);

  // optional uint32 outgoing_maneuver_index = 6;
  inline bool has_outgoing_maneuver_index() const;
  inline void clear_outgoing_maneuver_index();
  static const int kOutgoingManeuverIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 outgoing_maneuver_index() const;
  inline void set_outgoing_maneuver_index(::google::protobuf::uint32 value);

  // repeated .valhalla.StreetName street_names = 7;
  inline int street_names_size() const;
  inline void clear_street_names();
  static const int kStreetNamesFieldNumber = 7;
  inline const ::valhalla::StreetName& street_names(int index) const;
  inline ::valhalla::StreetName* mutable_street_names(int index);
  inline ::valhalla::StreetName* add_street_names();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      street_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_names();

  // optional string travel_mode = 8;
  inline bool has_travel_mode() const;
  inline void clear_travel_mode();
  static const int kTravelModeFieldNumber = 8;
  inline const ::std::string& travel_mode() const;
  inline void set_travel_mode(const ::std::string& value);
  inline void set_travel_mode(const char* value);
  inline void set_travel_mode(const char* value, size_t size);
  inline ::std::string* mutable_travel_mode();
  inline ::std::string* release_travel_mode();
  inline void set_allocated_travel_mode(::std::string* travel_mode);

  // optional string travel_mode_type = 9;
  inline bool has_travel_mode_type() const;
  inline void clear_travel_mode_type();
  static const int kTravelModeTypeFieldNumber = 9;
  inline const ::std::string& travel_mode_type() const;
  inline void set_travel_mode_type(const ::std::string& value);
  inline void set_travel_mode_type(const char* value);
  inline void set_travel_mode_type(const char* value, size_t size);
  inline ::std::string* mutable_travel_mode_type();
  inline ::std::string* release_travel_mode_type();
  inline void set_allocated_travel_mode_type(::std::string* travel_mode_type);

  // optional string driving_side = 10;
  inline bool has_driving_side() const;
  inline void clear_driving_side();
  static const int kDrivingSideFieldNumber = 10;
  inline const ::std::string& driving_side() const;
  inline void set_driving_side(const ::std::string& value);
  inline void set_driving_side(const char* value);
  inline void set_driving_side(const char* value, size_t size);
  inline ::std::string* mutable_driving_side();
  inline ::std::string* release_driving_side();
  inline void set_allocated_driving_side(::std::string* driving_side);

  // @@protoc_insertion_point(class_scope:valhalla.Step)
 private:
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_geometry_index_begin();
  inline void clear_has_geometry_index_begin();
  inline void set_has_geometry_index_end();
  inline void clear_has_geometry_index_end();
  inline void set_has_incoming_maneuver_index();
  inline void clear_has_incoming_maneuver_index();
  inline void set_has_outgoing_maneuver_index();
  inline void clear_has_outgoing_maneuver_index();
  inline void set_has_travel_mode();
  inline void clear_has_travel_mode();
  inline void set_has_travel_mode_type();
  inline void clear_has_travel_mode_type();
  inline void set_has_driving_side();
  inline void clear_has_driving_side();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float distance_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 geometry_index_begin_;
  ::google::protobuf::uint32 geometry_index_end_;
  ::google::protobuf::uint32 incoming_maneuver_index_;
  ::google::protobuf::uint32 outgoing_maneuver_index_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > street_names_;
  ::std::string* travel_mode_;
  ::std::string* travel_mode_type_;
  ::std::string* driving_side_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Step* default_instance_;
};
// -------------------------------------------------------------------

class SignElement : public ::google::protobuf::Message {
 public:
  SignElement();
  virtual ~SignElement();

  SignElement(const SignElement& from);

  inline SignElement& operator=(const SignElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignElement& default_instance();

  void Swap(SignElement* other);

  // implements Message ----------------------------------------------

  SignElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignElement& from);
  void MergeFrom(const SignElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool is_route_number = 2;
  inline bool has_is_route_number() const;
  inline void clear_is_route_number();
  static const int kIsRouteNumberFieldNumber = 2;
  inline bool is_route_number() const;
  inline void set_is_route_number(bool value);

  // optional uint32 consecutive_count = 3;
  inline bool has_consecutive_count() const;
  inline void clear_consecutive_count();
  static const int kConsecutiveCountFieldNumber = 3;
  inline ::google::protobuf::uint32 consecutive_count() const;
  inline void set_consecutive_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.SignElement)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_is_route_number();
  inline void clear_has_is_route_number();
  inline void set_has_consecutive_count();
  inline void clear_has_consecutive_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  bool is_route_number_;
  ::google::protobuf::uint32 consecutive_count_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static SignElement* default_instance_;
};
// -------------------------------------------------------------------

class Sign : public ::google::protobuf::Message {
 public:
  Sign();
  virtual ~Sign();

  Sign(const Sign& from);

  inline Sign& operator=(const Sign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sign& default_instance();

  void Swap(Sign* other);

  // implements Message ----------------------------------------------

  Sign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sign& from);
  void MergeFrom(const Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.SignElement exit_numbers = 1;
  inline int exit_numbers_size() const;
  inline void clear_exit_numbers();
  static const int kExitNumbersFieldNumber = 1;
  inline const ::valhalla::SignElement& exit_numbers(int index) const;
  inline ::valhalla::SignElement* mutable_exit_numbers(int index);
  inline ::valhalla::SignElement* add_exit_numbers();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
      exit_numbers() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
      mutable_exit_numbers();

  // repeated .valhalla.SignElement exit_onto_streets = 2;
  inline int exit_onto_streets_size() const;
  inline void clear_exit_onto_streets();
  static const int kExitOntoStreetsFieldNumber = 2;
  inline const ::valhalla::SignElement& exit_onto_streets(int index) const;
  inline ::valhalla::SignElement* mutable_exit_onto_streets(int index);
  inline ::valhalla::SignElement* add_exit_onto_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
      exit_onto_streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
      mutable_exit_onto_streets();

  // repeated .valhalla.SignElement exit_toward_locations = 3;
  inline int exit_toward_locations_size() const;
  inline void clear_exit_toward_locations();
  static const int kExitTowardLocationsFieldNumber = 3;
  inline const ::valhalla::SignElement& exit_toward_locations(int index) const;
  inline ::valhalla::SignElement* mutable_exit_toward_locations(int index);
  inline ::valhalla::SignElement* add_exit_toward_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
      exit_toward_locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
      mutable_exit_toward_locations();

  // repeated .valhalla.SignElement exit_names = 4;
  inline int exit_names_size() const;
  inline void clear_exit_names();
  static const int kExitNamesFieldNumber = 4;
  inline const ::valhalla::SignElement& exit_names(int index) const;
  inline ::valhalla::SignElement* mutable_exit_names(int index);
  inline ::valhalla::SignElement* add_exit_names();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
      exit_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
      mutable_exit_names();

  // @@protoc_insertion_point(class_scope:valhalla.Sign)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement > exit_numbers_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement > exit_onto_streets_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement > exit_toward_locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement > exit_names_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Sign* default_instance_;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  void Swap(Lane* other);

  // implements Message ----------------------------------------------

  Lane* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_valid = 1;
  inline bool has_is_valid() const;
  inline void clear_is_valid();
  static const int kIsValidFieldNumber = 1;
  inline bool is_valid() const;
  inline void set_is_valid(bool value);

  // repeated string indications = 2;
  inline int indications_size() const;
  inline void clear_indications();
  static const int kIndicationsFieldNumber = 2;
  inline const ::std::string& indications(int index) const;
  inline ::std::string* mutable_indications(int index);
  inline void set_indications(int index, const ::std::string& value);
  inline void set_indications(int index, const char* value);
  inline void set_indications(int index, const char* value, size_t size);
  inline ::std::string* add_indications();
  inline void add_indications(const ::std::string& value);
  inline void add_indications(const char* value);
  inline void add_indications(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& indications() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_indications();

  // @@protoc_insertion_point(class_scope:valhalla.Lane)
 private:
  inline void set_has_is_valid();
  inline void clear_has_is_valid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> indications_;
  bool is_valid_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Lane* default_instance_;
};
// -------------------------------------------------------------------

class Maneuver : public ::google::protobuf::Message {
 public:
  Maneuver();
  virtual ~Maneuver();

  Maneuver(const Maneuver& from);

  inline Maneuver& operator=(const Maneuver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Maneuver& default_instance();

  void Swap(Maneuver* other);

  // implements Message ----------------------------------------------

  Maneuver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Maneuver& from);
  void MergeFrom(const Maneuver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional uint32 geometry_index = 2;
  inline bool has_geometry_index() const;
  inline void clear_geometry_index();
  static const int kGeometryIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 geometry_index() const;
  inline void set_geometry_index(::google::protobuf::uint32 value);

  // optional uint32 incoming_bearing = 3;
  inline bool has_incoming_bearing() const;
  inline void clear_incoming_bearing();
  static const int kIncomingBearingFieldNumber = 3;
  inline ::google::protobuf::uint32 incoming_bearing() const;
  inline void set_incoming_bearing(::google::protobuf::uint32 value);

  // optional uint32 outgoing_bearing = 4;
  inline bool has_outgoing_bearing() const;
  inline void clear_outgoing_bearing();
  static const int kOutgoingBearingFieldNumber = 4;
  inline ::google::protobuf::uint32 outgoing_bearing() const;
  inline void set_outgoing_bearing(::google::protobuf::uint32 value);

  // repeated .valhalla.StreetName street_names = 5;
  inline int street_names_size() const;
  inline void clear_street_names();
  static const int kStreetNamesFieldNumber = 5;
  inline const ::valhalla::StreetName& street_names(int index) const;
  inline ::valhalla::StreetName* mutable_street_names(int index);
  inline ::valhalla::StreetName* add_street_names();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      street_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_names();

  // optional .valhalla.Sign sign = 6;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 6;
  inline const ::valhalla::Sign& sign() const;
  inline ::valhalla::Sign* mutable_sign();
  inline ::valhalla::Sign* release_sign();
  inline void set_allocated_sign(::valhalla::Sign* sign);

  // optional .valhalla.Lane lane = 7;
  inline bool has_lane() const;
  inline void clear_lane();
  static const int kLaneFieldNumber = 7;
  inline const ::valhalla::Lane& lane() const;
  inline ::valhalla::Lane* mutable_lane();
  inline ::valhalla::Lane* release_lane();
  inline void set_allocated_lane(::valhalla::Lane* lane);

  // optional bool is_obvious = 8;
  inline bool has_is_obvious() const;
  inline void clear_is_obvious();
  static const int kIsObviousFieldNumber = 8;
  inline bool is_obvious() const;
  inline void set_is_obvious(bool value);

  // optional bool is_verbal_multi_cue = 9;
  inline bool has_is_verbal_multi_cue() const;
  inline void clear_is_verbal_multi_cue();
  static const int kIsVerbalMultiCueFieldNumber = 9;
  inline bool is_verbal_multi_cue() const;
  inline void set_is_verbal_multi_cue(bool value);

  // optional string text_instruction = 10;
  inline bool has_text_instruction() const;
  inline void clear_text_instruction();
  static const int kTextInstructionFieldNumber = 10;
  inline const ::std::string& text_instruction() const;
  inline void set_text_instruction(const ::std::string& value);
  inline void set_text_instruction(const char* value);
  inline void set_text_instruction(const char* value, size_t size);
  inline ::std::string* mutable_text_instruction();
  inline ::std::string* release_text_instruction();
  inline void set_allocated_text_instruction(::std::string* text_instruction);

  // optional string verbal_transition_alert_instruction = 11;
  inline bool has_verbal_transition_alert_instruction() const;
  inline void clear_verbal_transition_alert_instruction();
  static const int kVerbalTransitionAlertInstructionFieldNumber = 11;
  inline const ::std::string& verbal_transition_alert_instruction() const;
  inline void set_verbal_transition_alert_instruction(const ::std::string& value);
  inline void set_verbal_transition_alert_instruction(const char* value);
  inline void set_verbal_transition_alert_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_transition_alert_instruction();
  inline ::std::string* release_verbal_transition_alert_instruction();
  inline void set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction);

  // optional string verbal_pre_transition_instruction = 12;
  inline bool has_verbal_pre_transition_instruction() const;
  inline void clear_verbal_pre_transition_instruction();
  static const int kVerbalPreTransitionInstructionFieldNumber = 12;
  inline const ::std::string& verbal_pre_transition_instruction() const;
  inline void set_verbal_pre_transition_instruction(const ::std::string& value);
  inline void set_verbal_pre_transition_instruction(const char* value);
  inline void set_verbal_pre_transition_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_pre_transition_instruction();
  inline ::std::string* release_verbal_pre_transition_instruction();
  inline void set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction);

  // optional string verbal_post_transition_instruction = 13;
  inline bool has_verbal_post_transition_instruction() const;
  inline void clear_verbal_post_transition_instruction();
  static const int kVerbalPostTransitionInstructionFieldNumber = 13;
  inline const ::std::string& verbal_post_transition_instruction() const;
  inline void set_verbal_post_transition_instruction(const ::std::string& value);
  inline void set_verbal_post_transition_instruction(const char* value);
  inline void set_verbal_post_transition_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_post_transition_instruction();
  inline ::std::string* release_verbal_post_transition_instruction();
  inline void set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction);

  // @@protoc_insertion_point(class_scope:valhalla.Maneuver)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_geometry_index();
  inline void clear_has_geometry_index();
  inline void set_has_incoming_bearing();
  inline void clear_has_incoming_bearing();
  inline void set_has_outgoing_bearing();
  inline void clear_has_outgoing_bearing();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_lane();
  inline void clear_has_lane();
  inline void set_has_is_obvious();
  inline void clear_has_is_obvious();
  inline void set_has_is_verbal_multi_cue();
  inline void clear_has_is_verbal_multi_cue();
  inline void set_has_text_instruction();
  inline void clear_has_text_instruction();
  inline void set_has_verbal_transition_alert_instruction();
  inline void clear_has_verbal_transition_alert_instruction();
  inline void set_has_verbal_pre_transition_instruction();
  inline void clear_has_verbal_pre_transition_instruction();
  inline void set_has_verbal_post_transition_instruction();
  inline void clear_has_verbal_post_transition_instruction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::google::protobuf::uint32 geometry_index_;
  ::google::protobuf::uint32 incoming_bearing_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > street_names_;
  ::valhalla::Sign* sign_;
  ::valhalla::Lane* lane_;
  ::google::protobuf::uint32 outgoing_bearing_;
  bool is_obvious_;
  bool is_verbal_multi_cue_;
  ::std::string* text_instruction_;
  ::std::string* verbal_transition_alert_instruction_;
  ::std::string* verbal_pre_transition_instruction_;
  ::std::string* verbal_post_transition_instruction_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Maneuver* default_instance_;
};
// -------------------------------------------------------------------

class Leg : public ::google::protobuf::Message {
 public:
  Leg();
  virtual ~Leg();

  Leg(const Leg& from);

  inline Leg& operator=(const Leg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Leg& default_instance();

  void Swap(Leg* other);

  // implements Message ----------------------------------------------

  Leg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Leg& from);
  void MergeFrom(const Leg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string summary = 1;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 1;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // optional float distance = 2;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 2;
  inline float distance() const;
  inline void set_distance(float value);

  // optional uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional .valhalla.BoundingBox bounding_box = 4;
  inline bool has_bounding_box() const;
  inline void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 4;
  inline const ::valhalla::BoundingBox& bounding_box() const;
  inline ::valhalla::BoundingBox* mutable_bounding_box();
  inline ::valhalla::BoundingBox* release_bounding_box();
  inline void set_allocated_bounding_box(::valhalla::BoundingBox* bounding_box);

  // optional string geometry = 5;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 5;
  inline const ::std::string& geometry() const;
  inline void set_geometry(const ::std::string& value);
  inline void set_geometry(const char* value);
  inline void set_geometry(const char* value, size_t size);
  inline ::std::string* mutable_geometry();
  inline ::std::string* release_geometry();
  inline void set_allocated_geometry(::std::string* geometry);

  // repeated .valhalla.Step steps = 6;
  inline int steps_size() const;
  inline void clear_steps();
  static const int kStepsFieldNumber = 6;
  inline const ::valhalla::Step& steps(int index) const;
  inline ::valhalla::Step* mutable_steps(int index);
  inline ::valhalla::Step* add_steps();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Step >&
      steps() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Step >*
      mutable_steps();

  // repeated .valhalla.Maneuver maneuvers = 7;
  inline int maneuvers_size() const;
  inline void clear_maneuvers();
  static const int kManeuversFieldNumber = 7;
  inline const ::valhalla::Maneuver& maneuvers(int index) const;
  inline ::valhalla::Maneuver* mutable_maneuvers(int index);
  inline ::valhalla::Maneuver* add_maneuvers();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Maneuver >&
      maneuvers() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Maneuver >*
      mutable_maneuvers();

  // @@protoc_insertion_point(class_scope:valhalla.Leg)
 private:
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bounding_box();
  inline void clear_has_bounding_box();
  inline void set_has_geometry();
  inline void clear_has_geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* summary_;
  float distance_;
  ::google::protobuf::uint32 duration_;
  ::valhalla::BoundingBox* bounding_box_;
  ::std::string* geometry_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Step > steps_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Maneuver > maneuvers_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Leg* default_instance_;
};
// -------------------------------------------------------------------

class Route : public ::google::protobuf::Message {
 public:
  Route();
  virtual ~Route();

  Route(const Route& from);

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Route& default_instance();

  void Swap(Route* other);

  // implements Message ----------------------------------------------

  Route* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float distance = 1;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 1;
  inline float distance() const;
  inline void set_distance(float value);

  // optional uint32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional .valhalla.BoundingBox bounding_box = 3;
  inline bool has_bounding_box() const;
  inline void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 3;
  inline const ::valhalla::BoundingBox& bounding_box() const;
  inline ::valhalla::BoundingBox* mutable_bounding_box();
  inline ::valhalla::BoundingBox* release_bounding_box();
  inline void set_allocated_bounding_box(::valhalla::BoundingBox* bounding_box);

  // repeated .valhalla.Leg legs = 4;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 4;
  inline const ::valhalla::Leg& legs(int index) const;
  inline ::valhalla::Leg* mutable_legs(int index);
  inline ::valhalla::Leg* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Leg >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Leg >*
      mutable_legs();

  // @@protoc_insertion_point(class_scope:valhalla.Route)
 private:
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_bounding_box();
  inline void clear_has_bounding_box();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float distance_;
  ::google::protobuf::uint32 duration_;
  ::valhalla::BoundingBox* bounding_box_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Leg > legs_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Route* default_instance_;
};
// -------------------------------------------------------------------

class Directions : public ::google::protobuf::Message {
 public:
  Directions();
  virtual ~Directions();

  Directions(const Directions& from);

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Directions& default_instance();

  void Swap(Directions* other);

  // implements Message ----------------------------------------------

  Directions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.Waypoint waypoints = 1;
  inline int waypoints_size() const;
  inline void clear_waypoints();
  static const int kWaypointsFieldNumber = 1;
  inline const ::valhalla::Waypoint& waypoints(int index) const;
  inline ::valhalla::Waypoint* mutable_waypoints(int index);
  inline ::valhalla::Waypoint* add_waypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Waypoint >&
      waypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Waypoint >*
      mutable_waypoints();

  // repeated .valhalla.Route routes = 2;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 2;
  inline const ::valhalla::Route& routes(int index) const;
  inline ::valhalla::Route* mutable_routes(int index);
  inline ::valhalla::Route* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Route >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Route >*
      mutable_routes();

  // optional .valhalla.BoundingBox bounding_box = 3;
  inline bool has_bounding_box() const;
  inline void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 3;
  inline const ::valhalla::BoundingBox& bounding_box() const;
  inline ::valhalla::BoundingBox* mutable_bounding_box();
  inline ::valhalla::BoundingBox* release_bounding_box();
  inline void set_allocated_bounding_box(::valhalla::BoundingBox* bounding_box);

  // optional string language_code = 4;
  inline bool has_language_code() const;
  inline void clear_language_code();
  static const int kLanguageCodeFieldNumber = 4;
  inline const ::std::string& language_code() const;
  inline void set_language_code(const ::std::string& value);
  inline void set_language_code(const char* value);
  inline void set_language_code(const char* value, size_t size);
  inline ::std::string* mutable_language_code();
  inline ::std::string* release_language_code();
  inline void set_allocated_language_code(::std::string* language_code);

  // optional string units = 5;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 5;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // optional uint32 status_code = 6;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 6;
  inline ::google::protobuf::uint32 status_code() const;
  inline void set_status_code(::google::protobuf::uint32 value);

  // optional string status_message = 7;
  inline bool has_status_message() const;
  inline void clear_status_message();
  static const int kStatusMessageFieldNumber = 7;
  inline const ::std::string& status_message() const;
  inline void set_status_message(const ::std::string& value);
  inline void set_status_message(const char* value);
  inline void set_status_message(const char* value, size_t size);
  inline ::std::string* mutable_status_message();
  inline ::std::string* release_status_message();
  inline void set_allocated_status_message(::std::string* status_message);

  // optional uint32 uuid = 8;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 8;
  inline ::google::protobuf::uint32 uuid() const;
  inline void set_uuid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:
  inline void set_has_bounding_box();
  inline void clear_has_bounding_box();
  inline void set_has_language_code();
  inline void clear_has_language_code();
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_status_message();
  inline void clear_has_status_message();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Waypoint > waypoints_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Route > routes_;
  ::valhalla::BoundingBox* bounding_box_;
  ::std::string* language_code_;
  ::std::string* units_;
  ::std::string* status_message_;
  ::google::protobuf::uint32 status_code_;
  ::google::protobuf::uint32 uuid_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Directions* default_instance_;
};
// ===================================================================


// ===================================================================

// Waypoint

// optional float lat = 1;
inline bool Waypoint::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Waypoint::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Waypoint::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Waypoint::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float Waypoint::lat() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.lat)
  return lat_;
}
inline void Waypoint::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.lat)
}

// optional float lon = 2;
inline bool Waypoint::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Waypoint::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Waypoint::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Waypoint::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float Waypoint::lon() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.lon)
  return lon_;
}
inline void Waypoint::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.lon)
}

// optional string type = 3;
inline bool Waypoint::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Waypoint::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Waypoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Waypoint::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Waypoint::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.type)
  return *type_;
}
inline void Waypoint::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.type)
}
inline void Waypoint::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Waypoint.type)
}
inline void Waypoint::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Waypoint.type)
}
inline ::std::string* Waypoint::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Waypoint.type)
  return type_;
}
inline ::std::string* Waypoint::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Waypoint::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Waypoint.type)
}

// optional uint32 bearing = 4;
inline bool Waypoint::has_bearing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Waypoint::set_has_bearing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Waypoint::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Waypoint::clear_bearing() {
  bearing_ = 0u;
  clear_has_bearing();
}
inline ::google::protobuf::uint32 Waypoint::bearing() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.bearing)
  return bearing_;
}
inline void Waypoint::set_bearing(::google::protobuf::uint32 value) {
  set_has_bearing();
  bearing_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.bearing)
}

// optional string name = 5;
inline bool Waypoint::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Waypoint::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Waypoint::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Waypoint::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Waypoint::name() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.name)
  return *name_;
}
inline void Waypoint::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.name)
}
inline void Waypoint::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Waypoint.name)
}
inline void Waypoint::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Waypoint.name)
}
inline ::std::string* Waypoint::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Waypoint.name)
  return name_;
}
inline ::std::string* Waypoint::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Waypoint::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Waypoint.name)
}

// optional string street = 6;
inline bool Waypoint::has_street() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Waypoint::set_has_street() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Waypoint::clear_has_street() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Waypoint::clear_street() {
  if (street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& Waypoint::street() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.street)
  return *street_;
}
inline void Waypoint::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.street)
}
inline void Waypoint::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Waypoint.street)
}
inline void Waypoint::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Waypoint.street)
}
inline ::std::string* Waypoint::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    street_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Waypoint.street)
  return street_;
}
inline ::std::string* Waypoint::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Waypoint::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Waypoint.street)
}

// optional string side_of_street = 7;
inline bool Waypoint::has_side_of_street() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Waypoint::set_has_side_of_street() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Waypoint::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Waypoint::clear_side_of_street() {
  if (side_of_street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    side_of_street_->clear();
  }
  clear_has_side_of_street();
}
inline const ::std::string& Waypoint::side_of_street() const {
  // @@protoc_insertion_point(field_get:valhalla.Waypoint.side_of_street)
  return *side_of_street_;
}
inline void Waypoint::set_side_of_street(const ::std::string& value) {
  set_has_side_of_street();
  if (side_of_street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    side_of_street_ = new ::std::string;
  }
  side_of_street_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Waypoint.side_of_street)
}
inline void Waypoint::set_side_of_street(const char* value) {
  set_has_side_of_street();
  if (side_of_street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    side_of_street_ = new ::std::string;
  }
  side_of_street_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Waypoint.side_of_street)
}
inline void Waypoint::set_side_of_street(const char* value, size_t size) {
  set_has_side_of_street();
  if (side_of_street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    side_of_street_ = new ::std::string;
  }
  side_of_street_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Waypoint.side_of_street)
}
inline ::std::string* Waypoint::mutable_side_of_street() {
  set_has_side_of_street();
  if (side_of_street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    side_of_street_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Waypoint.side_of_street)
  return side_of_street_;
}
inline ::std::string* Waypoint::release_side_of_street() {
  clear_has_side_of_street();
  if (side_of_street_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = side_of_street_;
    side_of_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Waypoint::set_allocated_side_of_street(::std::string* side_of_street) {
  if (side_of_street_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete side_of_street_;
  }
  if (side_of_street) {
    set_has_side_of_street();
    side_of_street_ = side_of_street;
  } else {
    clear_has_side_of_street();
    side_of_street_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Waypoint.side_of_street)
}

// -------------------------------------------------------------------

// BoundingBox

// optional float min_lat = 1;
inline bool BoundingBox::has_min_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundingBox::set_has_min_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundingBox::clear_has_min_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundingBox::clear_min_lat() {
  min_lat_ = 0;
  clear_has_min_lat();
}
inline float BoundingBox::min_lat() const {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.min_lat)
  return min_lat_;
}
inline void BoundingBox::set_min_lat(float value) {
  set_has_min_lat();
  min_lat_ = value;
  // @@protoc_insertion_point(field_set:valhalla.BoundingBox.min_lat)
}

// optional float min_lon = 2;
inline bool BoundingBox::has_min_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundingBox::set_has_min_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundingBox::clear_has_min_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundingBox::clear_min_lon() {
  min_lon_ = 0;
  clear_has_min_lon();
}
inline float BoundingBox::min_lon() const {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.min_lon)
  return min_lon_;
}
inline void BoundingBox::set_min_lon(float value) {
  set_has_min_lon();
  min_lon_ = value;
  // @@protoc_insertion_point(field_set:valhalla.BoundingBox.min_lon)
}

// optional float max_lat = 3;
inline bool BoundingBox::has_max_lat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundingBox::set_has_max_lat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoundingBox::clear_has_max_lat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoundingBox::clear_max_lat() {
  max_lat_ = 0;
  clear_has_max_lat();
}
inline float BoundingBox::max_lat() const {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.max_lat)
  return max_lat_;
}
inline void BoundingBox::set_max_lat(float value) {
  set_has_max_lat();
  max_lat_ = value;
  // @@protoc_insertion_point(field_set:valhalla.BoundingBox.max_lat)
}

// optional float max_lon = 4;
inline bool BoundingBox::has_max_lon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoundingBox::set_has_max_lon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoundingBox::clear_has_max_lon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoundingBox::clear_max_lon() {
  max_lon_ = 0;
  clear_has_max_lon();
}
inline float BoundingBox::max_lon() const {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.max_lon)
  return max_lon_;
}
inline void BoundingBox::set_max_lon(float value) {
  set_has_max_lon();
  max_lon_ = value;
  // @@protoc_insertion_point(field_set:valhalla.BoundingBox.max_lon)
}

// -------------------------------------------------------------------

// StreetName

// optional string text = 1;
inline bool StreetName::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreetName::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreetName::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreetName::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& StreetName::text() const {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.text)
  return *text_;
}
inline void StreetName::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.StreetName.text)
}
inline void StreetName::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.StreetName.text)
}
inline void StreetName::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.StreetName.text)
}
inline ::std::string* StreetName::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.StreetName.text)
  return text_;
}
inline ::std::string* StreetName::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StreetName::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.StreetName.text)
}

// optional bool is_route_number = 2;
inline bool StreetName::has_is_route_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreetName::set_has_is_route_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreetName::clear_has_is_route_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreetName::clear_is_route_number() {
  is_route_number_ = false;
  clear_has_is_route_number();
}
inline bool StreetName::is_route_number() const {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.is_route_number)
  return is_route_number_;
}
inline void StreetName::set_is_route_number(bool value) {
  set_has_is_route_number();
  is_route_number_ = value;
  // @@protoc_insertion_point(field_set:valhalla.StreetName.is_route_number)
}

// -------------------------------------------------------------------

// Step

// optional float distance = 1;
inline bool Step::has_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Step::set_has_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Step::clear_has_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Step::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Step::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.distance)
  return distance_;
}
inline void Step::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Step.distance)
}

// optional uint32 duration = 2;
inline bool Step::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Step::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Step::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Step::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 Step::duration() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.duration)
  return duration_;
}
inline void Step::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Step.duration)
}

// optional uint32 geometry_index_begin = 3;
inline bool Step::has_geometry_index_begin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Step::set_has_geometry_index_begin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Step::clear_has_geometry_index_begin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Step::clear_geometry_index_begin() {
  geometry_index_begin_ = 0u;
  clear_has_geometry_index_begin();
}
inline ::google::protobuf::uint32 Step::geometry_index_begin() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.geometry_index_begin)
  return geometry_index_begin_;
}
inline void Step::set_geometry_index_begin(::google::protobuf::uint32 value) {
  set_has_geometry_index_begin();
  geometry_index_begin_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Step.geometry_index_begin)
}

// optional uint32 geometry_index_end = 4;
inline bool Step::has_geometry_index_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Step::set_has_geometry_index_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Step::clear_has_geometry_index_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Step::clear_geometry_index_end() {
  geometry_index_end_ = 0u;
  clear_has_geometry_index_end();
}
inline ::google::protobuf::uint32 Step::geometry_index_end() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.geometry_index_end)
  return geometry_index_end_;
}
inline void Step::set_geometry_index_end(::google::protobuf::uint32 value) {
  set_has_geometry_index_end();
  geometry_index_end_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Step.geometry_index_end)
}

// optional uint32 incoming_maneuver_index = 5;
inline bool Step::has_incoming_maneuver_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Step::set_has_incoming_maneuver_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Step::clear_has_incoming_maneuver_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Step::clear_incoming_maneuver_index() {
  incoming_maneuver_index_ = 0u;
  clear_has_incoming_maneuver_index();
}
inline ::google::protobuf::uint32 Step::incoming_maneuver_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.incoming_maneuver_index)
  return incoming_maneuver_index_;
}
inline void Step::set_incoming_maneuver_index(::google::protobuf::uint32 value) {
  set_has_incoming_maneuver_index();
  incoming_maneuver_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Step.incoming_maneuver_index)
}

// optional uint32 outgoing_maneuver_index = 6;
inline bool Step::has_outgoing_maneuver_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Step::set_has_outgoing_maneuver_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Step::clear_has_outgoing_maneuver_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Step::clear_outgoing_maneuver_index() {
  outgoing_maneuver_index_ = 0u;
  clear_has_outgoing_maneuver_index();
}
inline ::google::protobuf::uint32 Step::outgoing_maneuver_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.outgoing_maneuver_index)
  return outgoing_maneuver_index_;
}
inline void Step::set_outgoing_maneuver_index(::google::protobuf::uint32 value) {
  set_has_outgoing_maneuver_index();
  outgoing_maneuver_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Step.outgoing_maneuver_index)
}

// repeated .valhalla.StreetName street_names = 7;
inline int Step::street_names_size() const {
  return street_names_.size();
}
inline void Step::clear_street_names() {
  street_names_.Clear();
}
inline const ::valhalla::StreetName& Step::street_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Step.street_names)
  return street_names_.Get(index);
}
inline ::valhalla::StreetName* Step::mutable_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Step.street_names)
  return street_names_.Mutable(index);
}
inline ::valhalla::StreetName* Step::add_street_names() {
  // @@protoc_insertion_point(field_add:valhalla.Step.street_names)
  return street_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
Step::street_names() const {
  // @@protoc_insertion_point(field_list:valhalla.Step.street_names)
  return street_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
Step::mutable_street_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Step.street_names)
  return &street_names_;
}

// optional string travel_mode = 8;
inline bool Step::has_travel_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Step::set_has_travel_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Step::clear_has_travel_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Step::clear_travel_mode() {
  if (travel_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_->clear();
  }
  clear_has_travel_mode();
}
inline const ::std::string& Step::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.travel_mode)
  return *travel_mode_;
}
inline void Step::set_travel_mode(const ::std::string& value) {
  set_has_travel_mode();
  if (travel_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_ = new ::std::string;
  }
  travel_mode_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Step.travel_mode)
}
inline void Step::set_travel_mode(const char* value) {
  set_has_travel_mode();
  if (travel_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_ = new ::std::string;
  }
  travel_mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Step.travel_mode)
}
inline void Step::set_travel_mode(const char* value, size_t size) {
  set_has_travel_mode();
  if (travel_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_ = new ::std::string;
  }
  travel_mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Step.travel_mode)
}
inline ::std::string* Step::mutable_travel_mode() {
  set_has_travel_mode();
  if (travel_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Step.travel_mode)
  return travel_mode_;
}
inline ::std::string* Step::release_travel_mode() {
  clear_has_travel_mode();
  if (travel_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = travel_mode_;
    travel_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Step::set_allocated_travel_mode(::std::string* travel_mode) {
  if (travel_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete travel_mode_;
  }
  if (travel_mode) {
    set_has_travel_mode();
    travel_mode_ = travel_mode;
  } else {
    clear_has_travel_mode();
    travel_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Step.travel_mode)
}

// optional string travel_mode_type = 9;
inline bool Step::has_travel_mode_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Step::set_has_travel_mode_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Step::clear_has_travel_mode_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Step::clear_travel_mode_type() {
  if (travel_mode_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_type_->clear();
  }
  clear_has_travel_mode_type();
}
inline const ::std::string& Step::travel_mode_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.travel_mode_type)
  return *travel_mode_type_;
}
inline void Step::set_travel_mode_type(const ::std::string& value) {
  set_has_travel_mode_type();
  if (travel_mode_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_type_ = new ::std::string;
  }
  travel_mode_type_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Step.travel_mode_type)
}
inline void Step::set_travel_mode_type(const char* value) {
  set_has_travel_mode_type();
  if (travel_mode_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_type_ = new ::std::string;
  }
  travel_mode_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Step.travel_mode_type)
}
inline void Step::set_travel_mode_type(const char* value, size_t size) {
  set_has_travel_mode_type();
  if (travel_mode_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_type_ = new ::std::string;
  }
  travel_mode_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Step.travel_mode_type)
}
inline ::std::string* Step::mutable_travel_mode_type() {
  set_has_travel_mode_type();
  if (travel_mode_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    travel_mode_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Step.travel_mode_type)
  return travel_mode_type_;
}
inline ::std::string* Step::release_travel_mode_type() {
  clear_has_travel_mode_type();
  if (travel_mode_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = travel_mode_type_;
    travel_mode_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Step::set_allocated_travel_mode_type(::std::string* travel_mode_type) {
  if (travel_mode_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete travel_mode_type_;
  }
  if (travel_mode_type) {
    set_has_travel_mode_type();
    travel_mode_type_ = travel_mode_type;
  } else {
    clear_has_travel_mode_type();
    travel_mode_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Step.travel_mode_type)
}

// optional string driving_side = 10;
inline bool Step::has_driving_side() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Step::set_has_driving_side() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Step::clear_has_driving_side() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Step::clear_driving_side() {
  if (driving_side_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driving_side_->clear();
  }
  clear_has_driving_side();
}
inline const ::std::string& Step::driving_side() const {
  // @@protoc_insertion_point(field_get:valhalla.Step.driving_side)
  return *driving_side_;
}
inline void Step::set_driving_side(const ::std::string& value) {
  set_has_driving_side();
  if (driving_side_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driving_side_ = new ::std::string;
  }
  driving_side_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Step.driving_side)
}
inline void Step::set_driving_side(const char* value) {
  set_has_driving_side();
  if (driving_side_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driving_side_ = new ::std::string;
  }
  driving_side_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Step.driving_side)
}
inline void Step::set_driving_side(const char* value, size_t size) {
  set_has_driving_side();
  if (driving_side_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driving_side_ = new ::std::string;
  }
  driving_side_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Step.driving_side)
}
inline ::std::string* Step::mutable_driving_side() {
  set_has_driving_side();
  if (driving_side_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driving_side_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Step.driving_side)
  return driving_side_;
}
inline ::std::string* Step::release_driving_side() {
  clear_has_driving_side();
  if (driving_side_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = driving_side_;
    driving_side_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Step::set_allocated_driving_side(::std::string* driving_side) {
  if (driving_side_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete driving_side_;
  }
  if (driving_side) {
    set_has_driving_side();
    driving_side_ = driving_side;
  } else {
    clear_has_driving_side();
    driving_side_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Step.driving_side)
}

// -------------------------------------------------------------------

// SignElement

// optional string text = 1;
inline bool SignElement::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignElement::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignElement::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignElement::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SignElement::text() const {
  // @@protoc_insertion_point(field_get:valhalla.SignElement.text)
  return *text_;
}
inline void SignElement::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.SignElement.text)
}
inline void SignElement::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.SignElement.text)
}
inline void SignElement::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.SignElement.text)
}
inline ::std::string* SignElement::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.SignElement.text)
  return text_;
}
inline ::std::string* SignElement::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignElement::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.SignElement.text)
}

// optional bool is_route_number = 2;
inline bool SignElement::has_is_route_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignElement::set_has_is_route_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignElement::clear_has_is_route_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignElement::clear_is_route_number() {
  is_route_number_ = false;
  clear_has_is_route_number();
}
inline bool SignElement::is_route_number() const {
  // @@protoc_insertion_point(field_get:valhalla.SignElement.is_route_number)
  return is_route_number_;
}
inline void SignElement::set_is_route_number(bool value) {
  set_has_is_route_number();
  is_route_number_ = value;
  // @@protoc_insertion_point(field_set:valhalla.SignElement.is_route_number)
}

// optional uint32 consecutive_count = 3;
inline bool SignElement::has_consecutive_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignElement::set_has_consecutive_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignElement::clear_has_consecutive_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignElement::clear_consecutive_count() {
  consecutive_count_ = 0u;
  clear_has_consecutive_count();
}
inline ::google::protobuf::uint32 SignElement::consecutive_count() const {
  // @@protoc_insertion_point(field_get:valhalla.SignElement.consecutive_count)
  return consecutive_count_;
}
inline void SignElement::set_consecutive_count(::google::protobuf::uint32 value) {
  set_has_consecutive_count();
  consecutive_count_ = value;
  // @@protoc_insertion_point(field_set:valhalla.SignElement.consecutive_count)
}

// -------------------------------------------------------------------

// Sign

// repeated .valhalla.SignElement exit_numbers = 1;
inline int Sign::exit_numbers_size() const {
  return exit_numbers_.size();
}
inline void Sign::clear_exit_numbers() {
  exit_numbers_.Clear();
}
inline const ::valhalla::SignElement& Sign::exit_numbers(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Sign.exit_numbers)
  return exit_numbers_.Get(index);
}
inline ::valhalla::SignElement* Sign::mutable_exit_numbers(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Sign.exit_numbers)
  return exit_numbers_.Mutable(index);
}
inline ::valhalla::SignElement* Sign::add_exit_numbers() {
  // @@protoc_insertion_point(field_add:valhalla.Sign.exit_numbers)
  return exit_numbers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
Sign::exit_numbers() const {
  // @@protoc_insertion_point(field_list:valhalla.Sign.exit_numbers)
  return exit_numbers_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
Sign::mutable_exit_numbers() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Sign.exit_numbers)
  return &exit_numbers_;
}

// repeated .valhalla.SignElement exit_onto_streets = 2;
inline int Sign::exit_onto_streets_size() const {
  return exit_onto_streets_.size();
}
inline void Sign::clear_exit_onto_streets() {
  exit_onto_streets_.Clear();
}
inline const ::valhalla::SignElement& Sign::exit_onto_streets(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Sign.exit_onto_streets)
  return exit_onto_streets_.Get(index);
}
inline ::valhalla::SignElement* Sign::mutable_exit_onto_streets(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Sign.exit_onto_streets)
  return exit_onto_streets_.Mutable(index);
}
inline ::valhalla::SignElement* Sign::add_exit_onto_streets() {
  // @@protoc_insertion_point(field_add:valhalla.Sign.exit_onto_streets)
  return exit_onto_streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
Sign::exit_onto_streets() const {
  // @@protoc_insertion_point(field_list:valhalla.Sign.exit_onto_streets)
  return exit_onto_streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
Sign::mutable_exit_onto_streets() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Sign.exit_onto_streets)
  return &exit_onto_streets_;
}

// repeated .valhalla.SignElement exit_toward_locations = 3;
inline int Sign::exit_toward_locations_size() const {
  return exit_toward_locations_.size();
}
inline void Sign::clear_exit_toward_locations() {
  exit_toward_locations_.Clear();
}
inline const ::valhalla::SignElement& Sign::exit_toward_locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Sign.exit_toward_locations)
  return exit_toward_locations_.Get(index);
}
inline ::valhalla::SignElement* Sign::mutable_exit_toward_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Sign.exit_toward_locations)
  return exit_toward_locations_.Mutable(index);
}
inline ::valhalla::SignElement* Sign::add_exit_toward_locations() {
  // @@protoc_insertion_point(field_add:valhalla.Sign.exit_toward_locations)
  return exit_toward_locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
Sign::exit_toward_locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Sign.exit_toward_locations)
  return exit_toward_locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
Sign::mutable_exit_toward_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Sign.exit_toward_locations)
  return &exit_toward_locations_;
}

// repeated .valhalla.SignElement exit_names = 4;
inline int Sign::exit_names_size() const {
  return exit_names_.size();
}
inline void Sign::clear_exit_names() {
  exit_names_.Clear();
}
inline const ::valhalla::SignElement& Sign::exit_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Sign.exit_names)
  return exit_names_.Get(index);
}
inline ::valhalla::SignElement* Sign::mutable_exit_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Sign.exit_names)
  return exit_names_.Mutable(index);
}
inline ::valhalla::SignElement* Sign::add_exit_names() {
  // @@protoc_insertion_point(field_add:valhalla.Sign.exit_names)
  return exit_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >&
Sign::exit_names() const {
  // @@protoc_insertion_point(field_list:valhalla.Sign.exit_names)
  return exit_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::SignElement >*
Sign::mutable_exit_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Sign.exit_names)
  return &exit_names_;
}

// -------------------------------------------------------------------

// Lane

// optional bool is_valid = 1;
inline bool Lane::has_is_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lane::set_has_is_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lane::clear_has_is_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lane::clear_is_valid() {
  is_valid_ = false;
  clear_has_is_valid();
}
inline bool Lane::is_valid() const {
  // @@protoc_insertion_point(field_get:valhalla.Lane.is_valid)
  return is_valid_;
}
inline void Lane::set_is_valid(bool value) {
  set_has_is_valid();
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Lane.is_valid)
}

// repeated string indications = 2;
inline int Lane::indications_size() const {
  return indications_.size();
}
inline void Lane::clear_indications() {
  indications_.Clear();
}
inline const ::std::string& Lane::indications(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Lane.indications)
  return indications_.Get(index);
}
inline ::std::string* Lane::mutable_indications(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Lane.indications)
  return indications_.Mutable(index);
}
inline void Lane::set_indications(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:valhalla.Lane.indications)
  indications_.Mutable(index)->assign(value);
}
inline void Lane::set_indications(int index, const char* value) {
  indications_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Lane.indications)
}
inline void Lane::set_indications(int index, const char* value, size_t size) {
  indications_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Lane.indications)
}
inline ::std::string* Lane::add_indications() {
  return indications_.Add();
}
inline void Lane::add_indications(const ::std::string& value) {
  indications_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Lane.indications)
}
inline void Lane::add_indications(const char* value) {
  indications_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Lane.indications)
}
inline void Lane::add_indications(const char* value, size_t size) {
  indications_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Lane.indications)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Lane::indications() const {
  // @@protoc_insertion_point(field_list:valhalla.Lane.indications)
  return indications_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Lane::mutable_indications() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Lane.indications)
  return &indications_;
}

// -------------------------------------------------------------------

// Maneuver

// optional string type = 1;
inline bool Maneuver::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Maneuver::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Maneuver::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Maneuver::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Maneuver::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.type)
  return *type_;
}
inline void Maneuver::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.type)
}
inline void Maneuver::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Maneuver.type)
}
inline void Maneuver::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Maneuver.type)
}
inline ::std::string* Maneuver::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.type)
  return type_;
}
inline ::std::string* Maneuver::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Maneuver::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.type)
}

// optional uint32 geometry_index = 2;
inline bool Maneuver::has_geometry_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Maneuver::set_has_geometry_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Maneuver::clear_has_geometry_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Maneuver::clear_geometry_index() {
  geometry_index_ = 0u;
  clear_has_geometry_index();
}
inline ::google::protobuf::uint32 Maneuver::geometry_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.geometry_index)
  return geometry_index_;
}
inline void Maneuver::set_geometry_index(::google::protobuf::uint32 value) {
  set_has_geometry_index();
  geometry_index_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.geometry_index)
}

// optional uint32 incoming_bearing = 3;
inline bool Maneuver::has_incoming_bearing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Maneuver::set_has_incoming_bearing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Maneuver::clear_has_incoming_bearing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Maneuver::clear_incoming_bearing() {
  incoming_bearing_ = 0u;
  clear_has_incoming_bearing();
}
inline ::google::protobuf::uint32 Maneuver::incoming_bearing() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.incoming_bearing)
  return incoming_bearing_;
}
inline void Maneuver::set_incoming_bearing(::google::protobuf::uint32 value) {
  set_has_incoming_bearing();
  incoming_bearing_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.incoming_bearing)
}

// optional uint32 outgoing_bearing = 4;
inline bool Maneuver::has_outgoing_bearing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Maneuver::set_has_outgoing_bearing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Maneuver::clear_has_outgoing_bearing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Maneuver::clear_outgoing_bearing() {
  outgoing_bearing_ = 0u;
  clear_has_outgoing_bearing();
}
inline ::google::protobuf::uint32 Maneuver::outgoing_bearing() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.outgoing_bearing)
  return outgoing_bearing_;
}
inline void Maneuver::set_outgoing_bearing(::google::protobuf::uint32 value) {
  set_has_outgoing_bearing();
  outgoing_bearing_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.outgoing_bearing)
}

// repeated .valhalla.StreetName street_names = 5;
inline int Maneuver::street_names_size() const {
  return street_names_.size();
}
inline void Maneuver::clear_street_names() {
  street_names_.Clear();
}
inline const ::valhalla::StreetName& Maneuver::street_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.street_names)
  return street_names_.Get(index);
}
inline ::valhalla::StreetName* Maneuver::mutable_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.street_names)
  return street_names_.Mutable(index);
}
inline ::valhalla::StreetName* Maneuver::add_street_names() {
  // @@protoc_insertion_point(field_add:valhalla.Maneuver.street_names)
  return street_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
Maneuver::street_names() const {
  // @@protoc_insertion_point(field_list:valhalla.Maneuver.street_names)
  return street_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
Maneuver::mutable_street_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Maneuver.street_names)
  return &street_names_;
}

// optional .valhalla.Sign sign = 6;
inline bool Maneuver::has_sign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Maneuver::set_has_sign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Maneuver::clear_has_sign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Maneuver::clear_sign() {
  if (sign_ != NULL) sign_->::valhalla::Sign::Clear();
  clear_has_sign();
}
inline const ::valhalla::Sign& Maneuver::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.sign)
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
}
inline ::valhalla::Sign* Maneuver::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::valhalla::Sign;
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.sign)
  return sign_;
}
inline ::valhalla::Sign* Maneuver::release_sign() {
  clear_has_sign();
  ::valhalla::Sign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void Maneuver::set_allocated_sign(::valhalla::Sign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.sign)
}

// optional .valhalla.Lane lane = 7;
inline bool Maneuver::has_lane() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Maneuver::set_has_lane() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Maneuver::clear_has_lane() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Maneuver::clear_lane() {
  if (lane_ != NULL) lane_->::valhalla::Lane::Clear();
  clear_has_lane();
}
inline const ::valhalla::Lane& Maneuver::lane() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.lane)
  return lane_ != NULL ? *lane_ : *default_instance_->lane_;
}
inline ::valhalla::Lane* Maneuver::mutable_lane() {
  set_has_lane();
  if (lane_ == NULL) lane_ = new ::valhalla::Lane;
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.lane)
  return lane_;
}
inline ::valhalla::Lane* Maneuver::release_lane() {
  clear_has_lane();
  ::valhalla::Lane* temp = lane_;
  lane_ = NULL;
  return temp;
}
inline void Maneuver::set_allocated_lane(::valhalla::Lane* lane) {
  delete lane_;
  lane_ = lane;
  if (lane) {
    set_has_lane();
  } else {
    clear_has_lane();
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.lane)
}

// optional bool is_obvious = 8;
inline bool Maneuver::has_is_obvious() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Maneuver::set_has_is_obvious() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Maneuver::clear_has_is_obvious() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Maneuver::clear_is_obvious() {
  is_obvious_ = false;
  clear_has_is_obvious();
}
inline bool Maneuver::is_obvious() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.is_obvious)
  return is_obvious_;
}
inline void Maneuver::set_is_obvious(bool value) {
  set_has_is_obvious();
  is_obvious_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.is_obvious)
}

// optional bool is_verbal_multi_cue = 9;
inline bool Maneuver::has_is_verbal_multi_cue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Maneuver::set_has_is_verbal_multi_cue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Maneuver::clear_has_is_verbal_multi_cue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Maneuver::clear_is_verbal_multi_cue() {
  is_verbal_multi_cue_ = false;
  clear_has_is_verbal_multi_cue();
}
inline bool Maneuver::is_verbal_multi_cue() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.is_verbal_multi_cue)
  return is_verbal_multi_cue_;
}
inline void Maneuver::set_is_verbal_multi_cue(bool value) {
  set_has_is_verbal_multi_cue();
  is_verbal_multi_cue_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.is_verbal_multi_cue)
}

// optional string text_instruction = 10;
inline bool Maneuver::has_text_instruction() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Maneuver::set_has_text_instruction() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Maneuver::clear_has_text_instruction() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Maneuver::clear_text_instruction() {
  if (text_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_instruction_->clear();
  }
  clear_has_text_instruction();
}
inline const ::std::string& Maneuver::text_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.text_instruction)
  return *text_instruction_;
}
inline void Maneuver::set_text_instruction(const ::std::string& value) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.text_instruction)
}
inline void Maneuver::set_text_instruction(const char* value) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Maneuver.text_instruction)
}
inline void Maneuver::set_text_instruction(const char* value, size_t size) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Maneuver.text_instruction)
}
inline ::std::string* Maneuver::mutable_text_instruction() {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_instruction_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.text_instruction)
  return text_instruction_;
}
inline ::std::string* Maneuver::release_text_instruction() {
  clear_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_instruction_;
    text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Maneuver::set_allocated_text_instruction(::std::string* text_instruction) {
  if (text_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_instruction_;
  }
  if (text_instruction) {
    set_has_text_instruction();
    text_instruction_ = text_instruction;
  } else {
    clear_has_text_instruction();
    text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.text_instruction)
}

// optional string verbal_transition_alert_instruction = 11;
inline bool Maneuver::has_verbal_transition_alert_instruction() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Maneuver::set_has_verbal_transition_alert_instruction() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Maneuver::clear_has_verbal_transition_alert_instruction() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Maneuver::clear_verbal_transition_alert_instruction() {
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_transition_alert_instruction_->clear();
  }
  clear_has_verbal_transition_alert_instruction();
}
inline const ::std::string& Maneuver::verbal_transition_alert_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.verbal_transition_alert_instruction)
  return *verbal_transition_alert_instruction_;
}
inline void Maneuver::set_verbal_transition_alert_instruction(const ::std::string& value) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.verbal_transition_alert_instruction)
}
inline void Maneuver::set_verbal_transition_alert_instruction(const char* value) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Maneuver.verbal_transition_alert_instruction)
}
inline void Maneuver::set_verbal_transition_alert_instruction(const char* value, size_t size) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Maneuver.verbal_transition_alert_instruction)
}
inline ::std::string* Maneuver::mutable_verbal_transition_alert_instruction() {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.verbal_transition_alert_instruction)
  return verbal_transition_alert_instruction_;
}
inline ::std::string* Maneuver::release_verbal_transition_alert_instruction() {
  clear_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = verbal_transition_alert_instruction_;
    verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Maneuver::set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction) {
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete verbal_transition_alert_instruction_;
  }
  if (verbal_transition_alert_instruction) {
    set_has_verbal_transition_alert_instruction();
    verbal_transition_alert_instruction_ = verbal_transition_alert_instruction;
  } else {
    clear_has_verbal_transition_alert_instruction();
    verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.verbal_transition_alert_instruction)
}

// optional string verbal_pre_transition_instruction = 12;
inline bool Maneuver::has_verbal_pre_transition_instruction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Maneuver::set_has_verbal_pre_transition_instruction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Maneuver::clear_has_verbal_pre_transition_instruction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Maneuver::clear_verbal_pre_transition_instruction() {
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_pre_transition_instruction_->clear();
  }
  clear_has_verbal_pre_transition_instruction();
}
inline const ::std::string& Maneuver::verbal_pre_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.verbal_pre_transition_instruction)
  return *verbal_pre_transition_instruction_;
}
inline void Maneuver::set_verbal_pre_transition_instruction(const ::std::string& value) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.verbal_pre_transition_instruction)
}
inline void Maneuver::set_verbal_pre_transition_instruction(const char* value) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Maneuver.verbal_pre_transition_instruction)
}
inline void Maneuver::set_verbal_pre_transition_instruction(const char* value, size_t size) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Maneuver.verbal_pre_transition_instruction)
}
inline ::std::string* Maneuver::mutable_verbal_pre_transition_instruction() {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.verbal_pre_transition_instruction)
  return verbal_pre_transition_instruction_;
}
inline ::std::string* Maneuver::release_verbal_pre_transition_instruction() {
  clear_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = verbal_pre_transition_instruction_;
    verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Maneuver::set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction) {
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete verbal_pre_transition_instruction_;
  }
  if (verbal_pre_transition_instruction) {
    set_has_verbal_pre_transition_instruction();
    verbal_pre_transition_instruction_ = verbal_pre_transition_instruction;
  } else {
    clear_has_verbal_pre_transition_instruction();
    verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.verbal_pre_transition_instruction)
}

// optional string verbal_post_transition_instruction = 13;
inline bool Maneuver::has_verbal_post_transition_instruction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Maneuver::set_has_verbal_post_transition_instruction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Maneuver::clear_has_verbal_post_transition_instruction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Maneuver::clear_verbal_post_transition_instruction() {
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_post_transition_instruction_->clear();
  }
  clear_has_verbal_post_transition_instruction();
}
inline const ::std::string& Maneuver::verbal_post_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.Maneuver.verbal_post_transition_instruction)
  return *verbal_post_transition_instruction_;
}
inline void Maneuver::set_verbal_post_transition_instruction(const ::std::string& value) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Maneuver.verbal_post_transition_instruction)
}
inline void Maneuver::set_verbal_post_transition_instruction(const char* value) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Maneuver.verbal_post_transition_instruction)
}
inline void Maneuver::set_verbal_post_transition_instruction(const char* value, size_t size) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Maneuver.verbal_post_transition_instruction)
}
inline ::std::string* Maneuver::mutable_verbal_post_transition_instruction() {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Maneuver.verbal_post_transition_instruction)
  return verbal_post_transition_instruction_;
}
inline ::std::string* Maneuver::release_verbal_post_transition_instruction() {
  clear_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = verbal_post_transition_instruction_;
    verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Maneuver::set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction) {
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete verbal_post_transition_instruction_;
  }
  if (verbal_post_transition_instruction) {
    set_has_verbal_post_transition_instruction();
    verbal_post_transition_instruction_ = verbal_post_transition_instruction;
  } else {
    clear_has_verbal_post_transition_instruction();
    verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Maneuver.verbal_post_transition_instruction)
}

// -------------------------------------------------------------------

// Leg

// optional string summary = 1;
inline bool Leg::has_summary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Leg::set_has_summary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Leg::clear_has_summary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Leg::clear_summary() {
  if (summary_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& Leg::summary() const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.summary)
  return *summary_;
}
inline void Leg::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Leg.summary)
}
inline void Leg::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Leg.summary)
}
inline void Leg::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Leg.summary)
}
inline ::std::string* Leg::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    summary_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Leg.summary)
  return summary_;
}
inline ::std::string* Leg::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Leg::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Leg.summary)
}

// optional float distance = 2;
inline bool Leg::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Leg::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Leg::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Leg::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Leg::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.distance)
  return distance_;
}
inline void Leg::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Leg.distance)
}

// optional uint32 duration = 3;
inline bool Leg::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Leg::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Leg::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Leg::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 Leg::duration() const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.duration)
  return duration_;
}
inline void Leg::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Leg.duration)
}

// optional .valhalla.BoundingBox bounding_box = 4;
inline bool Leg::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Leg::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Leg::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Leg::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->::valhalla::BoundingBox::Clear();
  clear_has_bounding_box();
}
inline const ::valhalla::BoundingBox& Leg::bounding_box() const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.bounding_box)
  return bounding_box_ != NULL ? *bounding_box_ : *default_instance_->bounding_box_;
}
inline ::valhalla::BoundingBox* Leg::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) bounding_box_ = new ::valhalla::BoundingBox;
  // @@protoc_insertion_point(field_mutable:valhalla.Leg.bounding_box)
  return bounding_box_;
}
inline ::valhalla::BoundingBox* Leg::release_bounding_box() {
  clear_has_bounding_box();
  ::valhalla::BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline void Leg::set_allocated_bounding_box(::valhalla::BoundingBox* bounding_box) {
  delete bounding_box_;
  bounding_box_ = bounding_box;
  if (bounding_box) {
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Leg.bounding_box)
}

// optional string geometry = 5;
inline bool Leg::has_geometry() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Leg::set_has_geometry() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Leg::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Leg::clear_geometry() {
  if (geometry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_->clear();
  }
  clear_has_geometry();
}
inline const ::std::string& Leg::geometry() const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.geometry)
  return *geometry_;
}
inline void Leg::set_geometry(const ::std::string& value) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Leg.geometry)
}
inline void Leg::set_geometry(const char* value) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Leg.geometry)
}
inline void Leg::set_geometry(const char* value, size_t size) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Leg.geometry)
}
inline ::std::string* Leg::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Leg.geometry)
  return geometry_;
}
inline ::std::string* Leg::release_geometry() {
  clear_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = geometry_;
    geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Leg::set_allocated_geometry(::std::string* geometry) {
  if (geometry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete geometry_;
  }
  if (geometry) {
    set_has_geometry();
    geometry_ = geometry;
  } else {
    clear_has_geometry();
    geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Leg.geometry)
}

// repeated .valhalla.Step steps = 6;
inline int Leg::steps_size() const {
  return steps_.size();
}
inline void Leg::clear_steps() {
  steps_.Clear();
}
inline const ::valhalla::Step& Leg::steps(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.steps)
  return steps_.Get(index);
}
inline ::valhalla::Step* Leg::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Leg.steps)
  return steps_.Mutable(index);
}
inline ::valhalla::Step* Leg::add_steps() {
  // @@protoc_insertion_point(field_add:valhalla.Leg.steps)
  return steps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Step >&
Leg::steps() const {
  // @@protoc_insertion_point(field_list:valhalla.Leg.steps)
  return steps_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Step >*
Leg::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Leg.steps)
  return &steps_;
}

// repeated .valhalla.Maneuver maneuvers = 7;
inline int Leg::maneuvers_size() const {
  return maneuvers_.size();
}
inline void Leg::clear_maneuvers() {
  maneuvers_.Clear();
}
inline const ::valhalla::Maneuver& Leg::maneuvers(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Leg.maneuvers)
  return maneuvers_.Get(index);
}
inline ::valhalla::Maneuver* Leg::mutable_maneuvers(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Leg.maneuvers)
  return maneuvers_.Mutable(index);
}
inline ::valhalla::Maneuver* Leg::add_maneuvers() {
  // @@protoc_insertion_point(field_add:valhalla.Leg.maneuvers)
  return maneuvers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Maneuver >&
Leg::maneuvers() const {
  // @@protoc_insertion_point(field_list:valhalla.Leg.maneuvers)
  return maneuvers_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Maneuver >*
Leg::mutable_maneuvers() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Leg.maneuvers)
  return &maneuvers_;
}

// -------------------------------------------------------------------

// Route

// optional float distance = 1;
inline bool Route::has_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Route::set_has_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Route::clear_has_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Route::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Route::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Route.distance)
  return distance_;
}
inline void Route::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Route.distance)
}

// optional uint32 duration = 2;
inline bool Route::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Route::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Route::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Route::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 Route::duration() const {
  // @@protoc_insertion_point(field_get:valhalla.Route.duration)
  return duration_;
}
inline void Route::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Route.duration)
}

// optional .valhalla.BoundingBox bounding_box = 3;
inline bool Route::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Route::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Route::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Route::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->::valhalla::BoundingBox::Clear();
  clear_has_bounding_box();
}
inline const ::valhalla::BoundingBox& Route::bounding_box() const {
  // @@protoc_insertion_point(field_get:valhalla.Route.bounding_box)
  return bounding_box_ != NULL ? *bounding_box_ : *default_instance_->bounding_box_;
}
inline ::valhalla::BoundingBox* Route::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) bounding_box_ = new ::valhalla::BoundingBox;
  // @@protoc_insertion_point(field_mutable:valhalla.Route.bounding_box)
  return bounding_box_;
}
inline ::valhalla::BoundingBox* Route::release_bounding_box() {
  clear_has_bounding_box();
  ::valhalla::BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline void Route::set_allocated_bounding_box(::valhalla::BoundingBox* bounding_box) {
  delete bounding_box_;
  bounding_box_ = bounding_box;
  if (bounding_box) {
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Route.bounding_box)
}

// repeated .valhalla.Leg legs = 4;
inline int Route::legs_size() const {
  return legs_.size();
}
inline void Route::clear_legs() {
  legs_.Clear();
}
inline const ::valhalla::Leg& Route::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Route.legs)
  return legs_.Get(index);
}
inline ::valhalla::Leg* Route::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Route.legs)
  return legs_.Mutable(index);
}
inline ::valhalla::Leg* Route::add_legs() {
  // @@protoc_insertion_point(field_add:valhalla.Route.legs)
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Leg >&
Route::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.Route.legs)
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Leg >*
Route::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Route.legs)
  return &legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.Waypoint waypoints = 1;
inline int Directions::waypoints_size() const {
  return waypoints_.size();
}
inline void Directions::clear_waypoints() {
  waypoints_.Clear();
}
inline const ::valhalla::Waypoint& Directions::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.waypoints)
  return waypoints_.Get(index);
}
inline ::valhalla::Waypoint* Directions::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.waypoints)
  return waypoints_.Mutable(index);
}
inline ::valhalla::Waypoint* Directions::add_waypoints() {
  // @@protoc_insertion_point(field_add:valhalla.Directions.waypoints)
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Waypoint >&
Directions::waypoints() const {
  // @@protoc_insertion_point(field_list:valhalla.Directions.waypoints)
  return waypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Waypoint >*
Directions::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.waypoints)
  return &waypoints_;
}

// repeated .valhalla.Route routes = 2;
inline int Directions::routes_size() const {
  return routes_.size();
}
inline void Directions::clear_routes() {
  routes_.Clear();
}
inline const ::valhalla::Route& Directions::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.routes)
  return routes_.Get(index);
}
inline ::valhalla::Route* Directions::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.routes)
  return routes_.Mutable(index);
}
inline ::valhalla::Route* Directions::add_routes() {
  // @@protoc_insertion_point(field_add:valhalla.Directions.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Route >&
Directions::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Directions.routes)
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Route >*
Directions::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.routes)
  return &routes_;
}

// optional .valhalla.BoundingBox bounding_box = 3;
inline bool Directions::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Directions::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Directions::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Directions::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->::valhalla::BoundingBox::Clear();
  clear_has_bounding_box();
}
inline const ::valhalla::BoundingBox& Directions::bounding_box() const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.bounding_box)
  return bounding_box_ != NULL ? *bounding_box_ : *default_instance_->bounding_box_;
}
inline ::valhalla::BoundingBox* Directions::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) bounding_box_ = new ::valhalla::BoundingBox;
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.bounding_box)
  return bounding_box_;
}
inline ::valhalla::BoundingBox* Directions::release_bounding_box() {
  clear_has_bounding_box();
  ::valhalla::BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline void Directions::set_allocated_bounding_box(::valhalla::BoundingBox* bounding_box) {
  delete bounding_box_;
  bounding_box_ = bounding_box;
  if (bounding_box) {
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Directions.bounding_box)
}

// optional string language_code = 4;
inline bool Directions::has_language_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Directions::set_has_language_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Directions::clear_has_language_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Directions::clear_language_code() {
  if (language_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_code_->clear();
  }
  clear_has_language_code();
}
inline const ::std::string& Directions::language_code() const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.language_code)
  return *language_code_;
}
inline void Directions::set_language_code(const ::std::string& value) {
  set_has_language_code();
  if (language_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_code_ = new ::std::string;
  }
  language_code_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Directions.language_code)
}
inline void Directions::set_language_code(const char* value) {
  set_has_language_code();
  if (language_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_code_ = new ::std::string;
  }
  language_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Directions.language_code)
}
inline void Directions::set_language_code(const char* value, size_t size) {
  set_has_language_code();
  if (language_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_code_ = new ::std::string;
  }
  language_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Directions.language_code)
}
inline ::std::string* Directions::mutable_language_code() {
  set_has_language_code();
  if (language_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.language_code)
  return language_code_;
}
inline ::std::string* Directions::release_language_code() {
  clear_has_language_code();
  if (language_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_code_;
    language_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Directions::set_allocated_language_code(::std::string* language_code) {
  if (language_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_code_;
  }
  if (language_code) {
    set_has_language_code();
    language_code_ = language_code;
  } else {
    clear_has_language_code();
    language_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Directions.language_code)
}

// optional string units = 5;
inline bool Directions::has_units() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Directions::set_has_units() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Directions::clear_has_units() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Directions::clear_units() {
  if (units_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& Directions::units() const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.units)
  return *units_;
}
inline void Directions::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  units_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Directions.units)
}
inline void Directions::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  units_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Directions.units)
}
inline void Directions::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Directions.units)
}
inline ::std::string* Directions::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.units)
  return units_;
}
inline ::std::string* Directions::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Directions::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Directions.units)
}

// optional uint32 status_code = 6;
inline bool Directions::has_status_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Directions::set_has_status_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Directions::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Directions::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 Directions::status_code() const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.status_code)
  return status_code_;
}
inline void Directions::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Directions.status_code)
}

// optional string status_message = 7;
inline bool Directions::has_status_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Directions::set_has_status_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Directions::clear_has_status_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Directions::clear_status_message() {
  if (status_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_->clear();
  }
  clear_has_status_message();
}
inline const ::std::string& Directions::status_message() const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.status_message)
  return *status_message_;
}
inline void Directions::set_status_message(const ::std::string& value) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Directions.status_message)
}
inline void Directions::set_status_message(const char* value) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Directions.status_message)
}
inline void Directions::set_status_message(const char* value, size_t size) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Directions.status_message)
}
inline ::std::string* Directions::mutable_status_message() {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.status_message)
  return status_message_;
}
inline ::std::string* Directions::release_status_message() {
  clear_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = status_message_;
    status_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Directions::set_allocated_status_message(::std::string* status_message) {
  if (status_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_message_;
  }
  if (status_message) {
    set_has_status_message();
    status_message_ = status_message;
  } else {
    clear_has_status_message();
    status_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Directions.status_message)
}

// optional uint32 uuid = 8;
inline bool Directions::has_uuid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Directions::set_has_uuid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Directions::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Directions::clear_uuid() {
  uuid_ = 0u;
  clear_has_uuid();
}
inline ::google::protobuf::uint32 Directions::uuid() const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.uuid)
  return uuid_;
}
inline void Directions::set_uuid(::google::protobuf::uint32 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:valhalla.Directions.uuid)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_route_2eproto__INCLUDED
